With
LISP.Strings,
Ada.Strings.Fixed;

Separate (LISP.Lists)

-- Read is perhaps overly complicated for a parsing example,
-- this is unavoidable given the constraints we are working
-- with in choosing to use strings AND to read/save directly in
-- valid LISP-text formant; namely:
--	(A) Generalized IO,
--		(1) No look-ahead is possible,
--		(2) No "unreading" is possible,
--	(B) LISP-text
--		(1) No way to tell, in advance, the length of
--			a list or element thereof.
--		(2) No way to tell, in advance, the type of an
--			element.
-- Therefore, the solution below is presented in a rather step-
-- wise manner: read the list from the stream, use that string
-- as the input of a string-to-list subprogram [consisting of
-- element recognition and list-construction]. Yes, this all
-- *COULD* [amd should] be done in a single pass; that however,
-- might be too much for a set of "intro into the language"
-- tutorials. (Though arguably an interpreter is, too.)
--
-- Lastly, it would be remiss of me to fail to explain the
-- advantages in the above after detailing the disadvantages:
--	(A) Generalized IO
--		(1) Because it is general, a stream may be
--			generated by anything from a disk-drive
--			to a radio-reciever to a network itself.
--		(2) Because is is general, this method allows
--			us to swap out bodies for read, so we
--			can test multiple implementations of a
--			stream-parser AND different file-formats.
--	(B) LISP Program-Text
--		(1) There need not be differing functions for
--			reading in source-code and reading in a
--			line typed by the user -- both may use
--			the same stream-functionality.
--		(2) Output is absurdly simeple -- just pipe all
--			the list's elements's To_String out and
--			make sure to output the '(' & ')' for
--			(respectively) before and after writing.

procedure Read(
		Stream : not null access Root_Stream_Type'Class;
		Item   : out LIST
	      ) is
    Use ASCII, Ada.Characters.Handling, Ada.Streams.Stream_IO, LISP.Strings;

    -- The actual ASCII Whitespace characters.
    Subtype Whitespace is Character Range NUL..' '
    with Static_Predicate => Whitespace in NUL | HT..CR |  ' ';

    -- The following function gets the next non white-space character.
    -- Used to "prime the pump" of the stream, as any leading
    -- whitespace should be disregarded.
    function Get_Next_Character Return Character is
    begin
	Return Result : Character:= ASCII.NUL do
	    loop
		Character'Read( Stream, Result );
		Exit When Result not in Whitespace;
	    end loop;
	End return;

    Exception
	When End_Error => Raise Parse_Error;
    end Get_Next_Character;


    ---------------------
    -- STATE VARIABLES --
    ---------------------
    -- Look_Ahead contains the imminent character from the stream.
    -- Current_Character, the working character.
    -- Stream_End marks whether the stream has been exhausted.
    Look_Ahead,
    Current_Character	: Character:= ASCII.NUL;
    Stream_End		: Boolean:= False;

    -- Advance shifts the old look_ahead into current_character
    -- and reads in a new character from the stream. In case of
    -- an empty stream a flag is set and NUL is substituted.
    -- The END_ERROR exception propigates if the flag is set.
    procedure Advance is
    begin
	Current_Character:= Look_Ahead;
	Character'Read( Stream, Look_Ahead );
	Stream_End:= False; -- Reset the flag.
    exception
	when END_ERROR =>
	    if not Stream_End then
		Stream_End:= True;
		Look_Ahead:= ASCII.NUL;
	    else
		Raise END_ERROR;
	    end if;
    end Advance;

    -- Build_String reads the characters from the stream, and
    -- returns the resultant string.
    Function Build_String Return String is

	Function Advance_Build(
			   Open_Parens : Natural;
			   In_String   : Boolean
			 ) return String is
	    OP : Constant Character:= '(';
	    CP : Constant Character:= ')';
	    C  : Constant Character:= Current_Character;

	    -- Active_Paren handles the increment and decriment
	    -- of the Open_Paren being passed to Build_String.
	    Function Active_Paren Return Natural is
	      ( if In_String then Open_Parens
	        elsif C = CP then Open_Parens - 1
	        elsif C = OP then Open_Parens + 1
		else Open_Parens -- Any other character
	       );

	    -- Inside_String is merely a shorthand for
	    -- determining when we enter/exit a string.
	    Function Inside_String Return Boolean is
	      (if C = '"' then Not In_String else In_String);

	begin
	    if Active_Paren = 0 then
		return "";
	    end if;

	    Advance;
	    return C & Advance_Build(
		Open_Parens => Active_Paren,
		In_String   => Inside_String
	    );
	exception
	    When End_Error => return "";
	end Advance_Build;

    begin
	return Advance_Build(0, False);
    end Build_String;


begin
    -- Here we "prime the pump" for our stream processing.
    Look_Ahead:= Get_Next_Character;

    -- Ensure we are starting a new list.
    if Look_Ahead /= '(' then
	raise Parse_Error;
    end if;

    -- We advance once to move '(' to the current position.
    Advance;

    Declare
	-- String_Value holds a List's string representation.
	String_Value : Constant String:= Build_String;

	-- Parse_String returns the List from the string which
	-- has been passed as the input.
	Function Parse_String( Input : String:= String_Value ) Return List is

	    Function Is_Numeric(S:String) Return Boolean Renames
	    	LISP.Strings.Valid_Number;

	    Function Element_Type( Input : String ) Return Data_Type is
		--Use Ada.Strings, Ada.Strings.Fixed;
		--Input   : String Renames S;
		Initial : Constant Character := Input(Input'First);
	    begin
		if Initial = '"' then
		    Return String_Type;
		elsif Initial = '(' then
		    Return List_Type;
		elsif To_Upper(Input) = "NULL" then
		  Return Empty_Type;
		elsif Is_Numeric(Input) then
		    -- If we add in floating types we'll need
		    -- to differentiate between integers and
		    -- the floating-type here.
		    Return Integer_Type;
		elsif Valid_ID(Input) then
		    Return Name_Type;
		end if;
		-- Since the above covers all possible values
		-- for Data_Types, if we made it here it
		-- indicates something went wrong in parsing.
		Raise PARSE_ERROR;
	    end Element_Type;

	    subtype Internal_Indecies is Positive Range
	      Positive'succ(Input'First)..Input'Last;

	    -- Scan is a procedure that, taking some index,
	    -- returns the next index of interest -- there are
	    -- two such functions: one for getting the start of
	    -- a new element, and one for getting the end of it.
	    Procedure Scan( Index : in out Internal_Indecies ) is
	    begin
		while Input(Index) in Whitespace
		  and Internal_Indecies'Last > Index loop
		    Index:= Internal_Indecies'Succ(Index);
		end loop;
	    end Scan;

	    Function Scan( Old_Index : in  Internal_Indecies;
		           New_Index : out Positive ) Return
	      LISP.Elements.Element is

		Start,
		Stop	  : Internal_Indecies:= Old_Index;

		Function This Return Character is
		  ( Input(Stop) );
		Function Element Return String is
		  ( Input(Start..Stop) );

		Function Is_List  Return Boolean is
		  (Input(Start) = '(');
		Function Is_String Return Boolean is
		  (Input(Start) = '"');

	    begin

		-- Because the element seperators ", " and " "
		-- are equivelant, we will strip out any intial
		-- comma found and procede as if it were whitespace.
		if Input(Start) = ',' then
		    Start:= Start + 1;
		end if;

		-- Consume leading whitespace, because we might
		-- have something like ( Bobby , Dave, ,Jo).
		Scan(Start);
		Stop:= Start;

		if Is_List then
		    -- if it is a list we need to balance parentheses.
		    declare
			Paren_Count   : Natural:= 1;
			Inside_String : Boolean:= False;
		    begin
			-- We don't want our start-index to
			-- terminate the loop prematurely.
			loop
			    Stop:= Internal_Indecies'Succ(Stop);

			    case this is
			    when '(' =>
				if not Inside_String then
				    Paren_Count:= Natural'Succ(Paren_Count);
				end if;
			    when ')' =>
				if not Inside_String then
				    Paren_Count:= Natural'Pred(Paren_Count);
				end if;
			    when '"' =>
				Inside_String:= not Inside_String;
			    when others => null;
			    end case;

			    exit when Paren_Count not in Positive
			    	   or Stop = Internal_Indecies'Last;
			end loop;

			if this /= ')' then
			    Raise PARSE_ERROR;
			end if;
		    end;
		else
		    -- If element is a string, then we need to
		    -- search for the closing quote, otherwise
		    -- we need to search for the next character
		    -- delimiting items [whitespace | ','].
		    while ( if Is_String then (if stop > start then this = '"')
			    else this not in Whitespace | ',' ) loop
			Stop:= Stop + 1;
		    end loop;

		    -- Now we correct for consuming delimiters,
		    -- or not consuming them (in string's case),
		    -- as we certainly don't want to have
		    -- "BOBBY " or "BOBBY," as an function-name
		    -- or leave the closing quote on our index.

		    Stop:= (if Is_String then Stop + 1 else Stop - 1);
		end if;

		-- Set the output-parameter.
		New_Index:= 1 + Stop;

		-- Yes, we already know whether or not the
		-- element is a string; however, using a case-
		-- statement [without OTHERS] ensures that all
		-- choices are covered... so if we change the
		-- what types the interpreter handles, we will
		-- recieve a compiler error informing us of it.
		case Element_Type(Element) is
		when Empty_Type   =>
		    Return Create;
		when Integer_Type =>
		    declare
			Value : Integer:= Integer'Value( Element );
		    begin
			Return Create(Value);
		    end;
		when Name_Type | String_Type   =>
		    -- Strings and identifiers are both strings,
		    -- the difference is that one is surrounded
		    -- by quotes, the other not; the following
		    -- conditional statement handles that for
		    -- our call to Create.
		    Return Create(
			Item => (if Is_String
				 then Get_Internals(Element)
				 else Element),
			Identifier => not Is_String
		    );
		when List_Type    =>
		    -- Recursion, Oy!
		    Return Create( Parse_String(Element) );
		end case;
	    end Scan;

	    Index : Positive:= Internal_Indecies'First;

	-------------------------
	--  PARSE_STRING BODY  --
	-------------------------
	begin
	    Return Result: List do
		PARSE_ELEMENTS:
		loop
		    Scan( Index );
		    declare
			Use Type LISP.Elements.Element;
			Working : LISP.Elements.Element
				Renames Scan( Index, Index );
			-- Yes, we could get rid of this whole
			-- declare-block by saying:
			--	Result.Append( Scan( Index, Index ) );
		    begin
			Result.Append( Working );
			exit PARSE_ELEMENTS when
			  Index not in Internal_Indecies'First..
			    Internal_Indecies'Pred(Internal_Indecies'Last);
		    end;
		end loop PARSE_ELEMENTS;
	    End return;
	end Parse_String;

    begin
	if String_Value'Length < 2 then raise PARSE_ERROR; end if;
	Item:= Parse_String;
    end;
end Read;
